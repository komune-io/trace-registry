package cccev.test.f2.certification.command

import cccev.core.certification.command.CertificationFillValuesCommand
import cccev.core.certification.entity.CertificationRepository
import cccev.core.certification.entity.SupportedValue
import cccev.core.concept.entity.InformationConcept
import cccev.f2.certification.CertificationEndpoint
import cccev.infra.neo4j.session
import cccev.test.CccevCucumberStepsDefinition
import cccev.test.CertificationKey
import cccev.test.EvidenceKey
import cccev.test.InformationConceptKey
import cccev.test.SupportedValueKey
import cccev.test.f2.certification.data.supportedValue
import f2.dsl.fnc.invokeWith
import io.cucumber.datatable.DataTable
import io.cucumber.java8.En
import org.assertj.core.api.Assertions
import org.neo4j.ogm.session.SessionFactory
import org.springframework.beans.factory.annotation.Autowired
import s2.bdd.assertion.AssertionBdd
import s2.bdd.data.TestContextKey
import s2.bdd.data.parser.extractList
import s2.bdd.data.parser.safeExtract

class CertificationFillValuesSteps: En, CccevCucumberStepsDefinition() {

    @Autowired
    private lateinit var certificationEndpoint: CertificationEndpoint

    @Autowired
    private lateinit var certificationRepository: CertificationRepository

    @Autowired
    private lateinit var sessionFactory: SessionFactory

    private lateinit var command: CertificationFillValuesCommand

    init {
        DataTableType(::certificationFillValuesParams)
        DataTableType(::supportedValueAssertParams)

        When("I fill values in the certification:") { dataTable: DataTable ->
            step {
                dataTable.asList(CertificationFillValuesParams::class.java)
                    .groupBy(CertificationFillValuesParams::certification)
                    .forEach { (identifier, params) ->
                        fillValues(identifier, params)
                    }
            }
        }

        When("Some values are filled in the certification:") { dataTable: DataTable ->
            step {
                dataTable.asList(CertificationFillValuesParams::class.java)
                    .groupBy(CertificationFillValuesParams::certification)
                    .forEach { (identifier, params) ->
                        fillValues(identifier, params)
                    }
            }
        }

        Then("The supported values should be created:") { dataTable: DataTable ->
            step {
                dataTable.asList(SupportedValueAssertParams::class.java)
                    .forEach { params ->
                        if (params.autogenerated) {
                            registerAutogeneratedSupportedValue(params)
                        }
                        assertValue(params)
                    }
            }
        }
    }

    private suspend fun fillValues(identifier: TestContextKey, params: Collection<CertificationFillValuesParams>) {
        command = CertificationFillValuesCommand(
            id = context.certificationIds[identifier] ?: identifier,
            rootRequirementCertificationId = null,
            values = params.associate { it.concept to it.value }
        )
        command.invokeWith(certificationEndpoint.certificationFillValues())
        registerNewlyCreatedSupportedValues(params)
    }

    private suspend fun registerNewlyCreatedSupportedValues(
        params: Collection<CertificationFillValuesParams>
    ) = sessionFactory.session { session ->
        params.forEach { param ->
            session.query(
                "MATCH (sv:${SupportedValue.LABEL})" +
                        "-[:${SupportedValue.PROVIDES_VALUE_FOR}]->(:${InformationConcept.LABEL} {identifier: \$icIdentifier})" +
                        "\nRETURN sv" +
                        "\nORDER BY sv.creationDate DESC" +
                        "\nLIMIT 1",
                mapOf("icIdentifier" to param.concept)
            ).map { it["sv"] as SupportedValue }
                .firstOrNull()
                ?.let { context.supportedValueIds[param.identifier] = it.id }
        }
    }

    private suspend fun registerAutogeneratedSupportedValue(params: SupportedValueAssertParams) = sessionFactory.session { session ->
        session.query(
            "MATCH (sv:${SupportedValue.LABEL})" +
                    "-[:${SupportedValue.PROVIDES_VALUE_FOR}]->(:${InformationConcept.LABEL} {identifier: \$icIdentifier})" +
                    "\nRETURN sv" +
                    "\nORDER BY sv.creationDate DESC" +
                    "\nLIMIT 1",
            mapOf("icIdentifier" to params.concept)
        ).map { it["sv"] as SupportedValue }
            .first()
            .let { context.supportedValueIds[params.identifier] = it.id }

    }

    private suspend fun assertValue(params: SupportedValueAssertParams) {
        val supportedValueId = context.supportedValueIds.safeGet(params.identifier)
        val supportedValue = certificationRepository.findSupportedValueById(supportedValueId)
        Assertions.assertThat(supportedValue).isNotNull

        AssertionBdd.supportedValue(certificationRepository).assertThat(supportedValue!!)
            .hasFields(
                value = params.value.parseNullableOrDefault(supportedValue.value),
                conceptId = params.concept?.let(context.conceptIds::safeGet)
                    ?: supportedValue.concept.id,
                evidenceIds = params.evidences?.map(context.evidenceIds::safeGet)
                    ?: supportedValue.evidences.map { it.id }
            )
    }

    private fun certificationFillValuesParams(entry: Map<String, String>) = CertificationFillValuesParams(
        identifier = entry["identifier"].orRandom(),
        certification = entry["certification"] ?: context.certificationIds.lastUsedKey,
        concept = entry.safeExtract("concept"),
        value = entry["value"]
    )

    private fun supportedValueAssertParams(entry: Map<String, String>) = SupportedValueAssertParams(
        identifier = entry.safeExtract("identifier"),
        concept = entry["concept"],
        value = entry["value"],
        evidences = entry.extractList("evidences").orEmpty().takeIf { "evidences" in entry },
        autogenerated = entry["autogenerated"]?.toBoolean() ?: false
    )

    private data class CertificationFillValuesParams(
        val identifier: SupportedValueKey,
        val certification: CertificationKey,
        val concept: InformationConceptKey,
        val value: String?
    )

    private data class SupportedValueAssertParams(
        val identifier: SupportedValueKey,
        val concept: InformationConceptKey?,
        val value: String?,
        val evidences: List<EvidenceKey>?,
        val autogenerated: Boolean
    )
}
