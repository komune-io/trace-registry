package io.komune.registry.test.control.core.cccev.certification.command

import io.cucumber.datatable.DataTable
import io.cucumber.java8.En
import io.komune.registry.control.core.cccev.certification.CertificationAggregateService
import io.komune.registry.control.core.cccev.certification.command.CertificationFillValuesCommand
import io.komune.registry.control.core.cccev.certification.entity.CertificationRepository
import io.komune.registry.control.core.cccev.certification.entity.SupportedValue
import io.komune.registry.control.core.cccev.concept.entity.InformationConcept
import io.komune.registry.infra.neo4j.session
import io.komune.registry.test.CertificationKey
import io.komune.registry.test.EvidenceKey
import io.komune.registry.test.InformationConceptKey
import io.komune.registry.test.RgCucumberStepsDefinition
import io.komune.registry.test.SupportedValueKey
import io.komune.registry.test.control.core.cccev.certification.data.supportedValue
import org.assertj.core.api.Assertions
import org.neo4j.ogm.session.SessionFactory
import org.springframework.beans.factory.annotation.Autowired
import s2.bdd.assertion.AssertionBdd
import s2.bdd.data.TestContextKey
import s2.bdd.data.parser.extractList
import s2.bdd.data.parser.safeExtract

class CertificationFillValuesSteps: En, RgCucumberStepsDefinition() {

    @Autowired
    private lateinit var certificationAggregateService: CertificationAggregateService

    @Autowired
    private lateinit var certificationRepository: CertificationRepository

    @Autowired
    private lateinit var sessionFactory: SessionFactory

    private lateinit var command: CertificationFillValuesCommand

    init {
        DataTableType(::certificationFillValuesParams)
        DataTableType(::supportedValueAssertParams)

        When("I fill values in the certification:") { dataTable: DataTable ->
            step {
                dataTable.asList(CertificationFillValuesParams::class.java)
                    .groupBy(CertificationFillValuesParams::certification)
                    .forEach { (identifier, params) ->
                        fillValues(identifier, params)
                    }
            }
        }

        When("Some values are filled in the certification:") { dataTable: DataTable ->
            step {
                dataTable.asList(CertificationFillValuesParams::class.java)
                    .groupBy(CertificationFillValuesParams::certification)
                    .forEach { (identifier, params) ->
                        fillValues(identifier, params)
                    }
            }
        }

        Then("The supported values should be created:") { dataTable: DataTable ->
            step {
                dataTable.asList(SupportedValueAssertParams::class.java)
                    .forEach { params ->
                        if (params.autogenerated) {
                            registerAutogeneratedSupportedValue(params)
                        }
                        assertValue(params)
                    }
            }
        }
    }

    private suspend fun fillValues(identifier: TestContextKey, params: Collection<CertificationFillValuesParams>) {
        command = CertificationFillValuesCommand(
            id = context.cccev.certificationIds[identifier] ?: identifier,
            rootRequirementCertificationId = null,
            values = params.associate { it.concept to it.value }
        )
        certificationAggregateService.fillValues(command)
        registerNewlyCreatedSupportedValues(params)
    }

    private suspend fun registerNewlyCreatedSupportedValues(
        params: Collection<CertificationFillValuesParams>
    ) = sessionFactory.session { session ->
        params.forEach { param ->
            session.query(
                "MATCH (sv:${SupportedValue.LABEL})" +
                        "-[:${SupportedValue.PROVIDES_VALUE_FOR}]->(:${InformationConcept.LABEL} {identifier: \$icIdentifier})" +
                        "\nRETURN sv" +
                        "\nORDER BY sv.creationDate DESC" +
                        "\nLIMIT 1",
                mapOf("icIdentifier" to param.concept)
            ).map { it["sv"] as SupportedValue }
                .firstOrNull()
                ?.let { context.cccev.supportedValueIds[param.identifier] = it.id }
        }
    }

    private suspend fun registerAutogeneratedSupportedValue(params: SupportedValueAssertParams) = sessionFactory.session { session ->
        session.query(
            "MATCH (sv:${SupportedValue.LABEL})" +
                    "-[:${SupportedValue.PROVIDES_VALUE_FOR}]->(:${InformationConcept.LABEL} {identifier: \$icIdentifier})" +
                    "\nRETURN sv" +
                    "\nORDER BY sv.creationDate DESC" +
                    "\nLIMIT 1",
            mapOf("icIdentifier" to params.concept)
        ).map { it["sv"] as SupportedValue }
            .first()
            .let { context.cccev.supportedValueIds[params.identifier] = it.id }

    }

    private suspend fun assertValue(params: SupportedValueAssertParams) {
        val supportedValueId = context.cccev.supportedValueIds.safeGet(params.identifier)
        val supportedValue = certificationRepository.findSupportedValueById(supportedValueId)
        Assertions.assertThat(supportedValue).isNotNull

        AssertionBdd.supportedValue(certificationRepository).assertThat(supportedValue!!)
            .hasFields(
                value = params.value.parseNullableOrDefault(supportedValue.value),
                conceptId = params.concept?.let(context.cccev.conceptIds::safeGet)
                    ?: supportedValue.concept.id,
                evidenceIds = params.evidences?.map(context.cccev.evidenceIds::safeGet)
                    ?: supportedValue.evidences.map { it.id }
            )
    }

    private fun certificationFillValuesParams(entry: Map<String, String>) = CertificationFillValuesParams(
        identifier = entry["identifier"].orRandom(),
        certification = entry["certification"] ?: context.cccev.certificationIds.lastUsedKey,
        concept = entry.safeExtract("concept"),
        value = entry["value"]
    )

    private fun supportedValueAssertParams(entry: Map<String, String>) = SupportedValueAssertParams(
        identifier = entry.safeExtract("identifier"),
        concept = entry["concept"],
        value = entry["value"],
        evidences = entry.extractList<EvidenceKey>("evidences").orEmpty().takeIf { "evidences" in entry },
        autogenerated = entry["autogenerated"]?.toBoolean() ?: false
    )

    private data class CertificationFillValuesParams(
        val identifier: SupportedValueKey,
        val certification: CertificationKey,
        val concept: InformationConceptKey,
        val value: String?
    )

    private data class SupportedValueAssertParams(
        val identifier: SupportedValueKey,
        val concept: InformationConceptKey?,
        val value: String?,
        val evidences: List<EvidenceKey>?,
        val autogenerated: Boolean
    )
}
